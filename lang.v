(* generated by Ott 0.24 from: lang.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.


Require Import Omega ClassicalChoice basis (* LibMap *). 


Set Implicit Arguments.

Definition nf_update B (r: nat -> B) (x : nat) (b: B) (y : nat) : B :=
  if Peano_dec.eq_nat_dec x y then b else r y.

Definition ffun B :=
  { f: nat -> option B & { n | forall m (LEQ: n <= m), f m = None} }.

Program Definition empty_map B : ffun B := 
  existT _ (fun y => None) (existT _ 0 _).

Program Definition ff_update B (r: ffun B) (x : nat) (b: B) : ffun B :=
  existT _ (fun y => if Peano_dec.eq_nat_dec x y then Some b else projT1 r y)
   (existT _ (max (projT1 (projT2 r)) (S x)) _).
Next Obligation.
  destruct r as (r & n & H); simpl in *.
  destruct (Peano_dec.eq_nat_dec x m); subst.
  eapply Max.max_lub_r in LEQ; omega. 
  eauto using Max.max_lub_l.
Qed.

 
Definition termvar := nat.
Lemma eq_termvar: forall (x y : termvar), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_termvar : ott_coq_equality.

Inductive exp : Set := 
 | Evar (x:termvar)
 | Eplus (E1:exp) (E2:exp).

Inductive bexp : Set := 
 | Beq (E1:exp) (E2:exp)
 | Bless (E1:exp) (E2:exp).

Inductive cmd : Set := 
 | Cskip : cmd
 | Cassign (x:termvar) (E:exp)
 | Cassume (B:bexp)
 | Cseq (C1:cmd) (C2:cmd)
 | Catomic (C:cmd)
 | Cloop (C:cmd)
 | Cinsloop (C1:cmd) (C2:cmd) (p:nat)
 | Cbreak : cmd
 | Cpar (C1:cmd) (C2:cmd)
 | Cchoice (C1:cmd) (C2:cmd).
(** definitions *)

(** funs edenot_funs *)
Fixpoint bdenot (x1:bexp) (x2:(nat -> nat)) : Prop:=
  match x1,x2 with
  | (Beq E1 E2) , ss =>   (edenot E1 ss )   =   (edenot E2 ss )  
  | (Bless E1 E2) , ss =>   (edenot E1 ss )   <   (edenot E2 ss )  
end
with edenot (x1:exp) (x2:(nat -> nat)) : nat:=
  match x1,x2 with
  | (Evar x) , ss =>  ( ss   x ) 
  | (Eplus E1 E2) , ss =>  (  (edenot E1 ss )   +   (edenot E2 ss )  ) 
end.

(** definitions *)

(** funs abort_funs *)
Fixpoint aborts (x1:cmd) (x2:(nat -> nat)) (x3:nat) : Prop:=
  match x1,x2,x3 with
  | (Cseq C1 C2) , ss , p =>  (aborts C1 ss p ) 
  | (Cpar C1 C2) , ss , p =>   (aborts C1 ss p )   \/   (aborts C2 ss p )  
  | (Cinsloop Cskip C p') , ss , p =>  p'  <  p 
  | C , ss , p =>  False 
  | (Catomic C) , ss , p =>  (aborts C ss p ) 
end.

(** definitions *)

(* defns OpSemJudg *)
Inductive step : cmd -> (nat -> nat) -> nat -> cmd -> (nat -> nat) -> nat -> Prop :=    (* defn step *)
 | Sassign : forall (x:termvar) (E:exp) (ss:(nat -> nat)) (p:nat),
     step (Cassign x E) ss p Cskip  (nf_update  ss   x    (edenot E ss )  )   ( p  +   1  ) 
 | SseqI : forall (C1 C2:cmd) (ss:(nat -> nat)) (p:nat) (C1':cmd) (ss':(nat -> nat)) (p':nat),
     step C1 ss p C1' ss' p' ->
     step (Cseq C1 C2) ss p (Cseq C1' C2) ss' p'
 | SseqII : forall (C2:cmd) (ss:(nat -> nat)) (p:nat),
     step (Cseq Cskip C2) ss p C2 ss p
 | Sassume : forall (B:bexp) (ss:(nat -> nat)) (p:nat),
      (bdenot B ss )  ->
     step (Cassume B) ss p Cskip ss p
 | SparI : forall (C1 C2:cmd) (ss:(nat -> nat)) (p:nat) (C1':cmd) (ss':(nat -> nat)) (p':nat),
     step C1 ss p C1' ss' p' ->
     step (Cpar C1 C2) ss p (Cpar C1' C2) ss' p'
 | SparII : forall (C1 C2:cmd) (ss:(nat -> nat)) (p:nat) (C2':cmd) (ss':(nat -> nat)) (p':nat),
     step C2 ss p C2' ss' p' ->
     step (Cpar C1 C2) ss p (Cpar C1 C2') ss' p'
 | SparIII : forall (ss:(nat -> nat)) (p:nat),
     step (Cpar Cskip Cskip) ss p Cskip ss p
 | SloopEnter : forall (C:cmd) (ss:(nat -> nat)) (p:nat),
     step (Cloop C) ss p (Cinsloop C C p) ss p
 | SloopSeq : forall (C1 C:cmd) (p0:nat) (ss:(nat -> nat)) (p:nat) (C1':cmd) (ss':(nat -> nat)) (p':nat),
     step C1 ss p C1' ss' p' ->
     step (Cinsloop C1 C p0) ss p (Cinsloop C1' C p0) ss p
 | SloopBreakI : forall (C:cmd) (p0:nat) (ss:(nat -> nat)) (p:nat),
     step (Cinsloop Cbreak C p0) ss p Cskip ss  ( p  +   1  ) 
 | SloopBreakII : forall (C1 C:cmd) (p0:nat) (ss:(nat -> nat)) (p:nat),
     step (Cinsloop (Cseq Cbreak C1) C p0) ss p Cskip ss  ( p  +   1  ) 
 | SloopAssert : forall (C:cmd) (p0:nat) (ss:(nat -> nat)) (p:nat),
      p0  <  p  ->
     step (Cinsloop Cskip C p0) ss p (Cinsloop C C p) ss p
 | Satom : forall (C:cmd) (ss:(nat -> nat)) (p:nat) (ss':(nat -> nat)) (p':nat),
     step C ss p Cskip ss' p' ->
     step (Catomic C) ss p Cskip ss' p'
 | SnondetI : forall (C1 C2:cmd) (ss:(nat -> nat)) (p:nat),
     step (Cchoice C1 C2) ss p C1 ss p
 | SnondetII : forall (C1 C2:cmd) (ss:(nat -> nat)) (p:nat),
     step (Cchoice C1 C2) ss p C2 ss p.


